

/*===================================================================================
* 
*   Copyright (c) Userware (OpenSilver.net, CSHTML5.com)
*      
*   This file is part of both the OpenSilver Compiler (https://opensilver.net), which
*   is licensed under the MIT license (https://opensource.org/licenses/MIT), and the
*   CSHTML5 Compiler (http://cshtml5.com), which is dual-licensed (MIT + commercial).
*   
*   As stated in the MIT license, "the above copyright notice and this permission
*   notice shall be included in all copies or substantial portions of the Software."
*  
\*====================================================================================*/



// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            do {
                tok = scanner.LookAhead(TokenType.K_DECLARE, TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_VAR, TokenType.K_FUNCTION, TokenType.K_INTERFACE, TokenType.K_CLASS);
                switch (tok.Type)
                {
                    case TokenType.K_DECLARE:
                    case TokenType.K_NAMESPACE:
                    case TokenType.K_MODULE:
                    case TokenType.K_VAR:
                    case TokenType.K_FUNCTION:

                        
                        tok = scanner.LookAhead(TokenType.K_DECLARE);
                        if (tok.Type == TokenType.K_DECLARE)
                        {
                            tok = scanner.Scan(TokenType.K_DECLARE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.K_DECLARE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_DECLARE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                        }

                        
                        tok = scanner.LookAhead(TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_VAR, TokenType.K_FUNCTION);
                        switch (tok.Type)
                        {
                            case TokenType.K_NAMESPACE:
                            case TokenType.K_MODULE:
                                ParseNamespace(node);
                                break;
                            case TokenType.K_VAR:
                            case TokenType.K_FUNCTION:

                                
                                tok = scanner.LookAhead(TokenType.K_VAR, TokenType.K_FUNCTION);
                                switch (tok.Type)
                                {
                                    case TokenType.K_VAR:

                                        
                                        tok = scanner.Scan(TokenType.K_VAR);
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.K_VAR) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_VAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                            return;
                                        }

                                        
                                        ParseVariable(node);
                                        break;
                                    case TokenType.K_FUNCTION:

                                        
                                        tok = scanner.Scan(TokenType.K_FUNCTION);
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.K_FUNCTION) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_FUNCTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                            return;
                                        }

                                        
                                        ParseFunction(node);
                                        break;
                                    default:
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                        break;
                                }

                                
                                tok = scanner.LookAhead(TokenType.SEMICOLON);
                                if (tok.Type == TokenType.SEMICOLON)
                                {
                                    tok = scanner.Scan(TokenType.SEMICOLON);
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.SEMICOLON) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                        return;
                                    }
                                }
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                break;
                        }
                        break;
                    case TokenType.K_INTERFACE:
                        ParseInterface(node);
                        break;
                    case TokenType.K_CLASS:
                        ParseClass(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
                tok = scanner.LookAhead(TokenType.K_DECLARE, TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_VAR, TokenType.K_FUNCTION, TokenType.K_INTERFACE, TokenType.K_CLASS);
            } while (tok.Type == TokenType.K_DECLARE
                || tok.Type == TokenType.K_NAMESPACE
                || tok.Type == TokenType.K_MODULE
                || tok.Type == TokenType.K_VAR
                || tok.Type == TokenType.K_FUNCTION
                || tok.Type == TokenType.K_INTERFACE
                || tok.Type == TokenType.K_CLASS);

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseNamespace(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Namespace), "Namespace");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.K_NAMESPACE, TokenType.K_MODULE);
            switch (tok.Type)
            {
                case TokenType.K_NAMESPACE:
                    tok = scanner.Scan(TokenType.K_NAMESPACE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_NAMESPACE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_NAMESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_MODULE:
                    tok = scanner.Scan(TokenType.K_MODULE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_MODULE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_MODULE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
            if (tok.Type == TokenType.DOUBLEQUOTE
                || tok.Type == TokenType.SIMPLEQUOTE)
            {
                tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
                switch (tok.Type)
                {
                    case TokenType.DOUBLEQUOTE:
                        tok = scanner.Scan(TokenType.DOUBLEQUOTE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DOUBLEQUOTE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.SIMPLEQUOTE:
                        tok = scanner.Scan(TokenType.SIMPLEQUOTE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.SIMPLEQUOTE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIMPLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            
            tok = scanner.LookAhead(TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED, TokenType.DOTIDENT);
            switch (tok.Type)
            {
                case TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED:
                    tok = scanner.Scan(TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DOTIDENT:
                    tok = scanner.Scan(TokenType.DOTIDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOTIDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
            if (tok.Type == TokenType.DOUBLEQUOTE
                || tok.Type == TokenType.SIMPLEQUOTE)
            {
                tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
                switch (tok.Type)
                {
                    case TokenType.DOUBLEQUOTE:
                        tok = scanner.Scan(TokenType.DOUBLEQUOTE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DOUBLEQUOTE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.SIMPLEQUOTE:
                        tok = scanner.Scan(TokenType.SIMPLEQUOTE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.SIMPLEQUOTE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIMPLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            
            tok = scanner.Scan(TokenType.LBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseNamespaceContent(node);

            
            tok = scanner.Scan(TokenType.RBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseNamespaceContent(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.NamespaceContent), "NamespaceContent");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_FUNCTION, TokenType.K_VAR, TokenType.IDENT, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE, TokenType.K_IMPORT, TokenType.K_EXPORT_EQ);
            while (tok.Type == TokenType.K_STATIC
                || tok.Type == TokenType.K_EXPORT
                || tok.Type == TokenType.K_READONLY
                || tok.Type == TokenType.K_CONST
                || tok.Type == TokenType.K_LET
                || tok.Type == TokenType.K_PUBLIC
                || tok.Type == TokenType.K_NAMESPACE
                || tok.Type == TokenType.K_MODULE
                || tok.Type == TokenType.K_FUNCTION
                || tok.Type == TokenType.K_VAR
                || tok.Type == TokenType.IDENT
                || tok.Type == TokenType.K_ENUM
                || tok.Type == TokenType.K_CLASS
                || tok.Type == TokenType.K_INTERFACE
                || tok.Type == TokenType.K_IMPORT
                || tok.Type == TokenType.K_EXPORT_EQ)
            {
                tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_FUNCTION, TokenType.K_VAR, TokenType.IDENT, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE, TokenType.K_IMPORT, TokenType.K_EXPORT_EQ);
                switch (tok.Type)
                {
                    case TokenType.K_STATIC:
                    case TokenType.K_EXPORT:
                    case TokenType.K_READONLY:
                    case TokenType.K_CONST:
                    case TokenType.K_LET:
                    case TokenType.K_PUBLIC:
                    case TokenType.K_NAMESPACE:
                    case TokenType.K_MODULE:
                    case TokenType.K_FUNCTION:
                    case TokenType.K_VAR:
                    case TokenType.IDENT:
                    case TokenType.K_ENUM:
                    case TokenType.K_CLASS:
                    case TokenType.K_INTERFACE:

                        
                        tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                        while (tok.Type == TokenType.K_STATIC
                            || tok.Type == TokenType.K_EXPORT
                            || tok.Type == TokenType.K_READONLY
                            || tok.Type == TokenType.K_CONST
                            || tok.Type == TokenType.K_LET
                            || tok.Type == TokenType.K_PUBLIC)
                        {
                            ParseAccessTag(node);
                        tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                        }

                        
                        tok = scanner.LookAhead(TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_FUNCTION, TokenType.K_VAR, TokenType.IDENT, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
                        switch (tok.Type)
                        {
                            case TokenType.K_NAMESPACE:
                            case TokenType.K_MODULE:
                                ParseNamespace(node);
                                break;
                            case TokenType.K_FUNCTION:
                            case TokenType.K_VAR:
                            case TokenType.IDENT:

                                
                                tok = scanner.LookAhead(TokenType.K_FUNCTION, TokenType.K_VAR, TokenType.IDENT);
                                switch (tok.Type)
                                {
                                    case TokenType.K_FUNCTION:

                                        
                                        tok = scanner.Scan(TokenType.K_FUNCTION);
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.K_FUNCTION) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_FUNCTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                            return;
                                        }

                                        
                                        ParseFunction(node);
                                        break;
                                    case TokenType.K_VAR:
                                    case TokenType.IDENT:

                                        
                                        tok = scanner.LookAhead(TokenType.K_VAR);
                                        if (tok.Type == TokenType.K_VAR)
                                        {
                                            tok = scanner.Scan(TokenType.K_VAR);
                                            n = node.CreateNode(tok, tok.ToString() );
                                            node.Token.UpdateRange(tok);
                                            node.Nodes.Add(n);
                                            if (tok.Type != TokenType.K_VAR) {
                                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_VAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                                return;
                                            }
                                        }

                                        
                                        ParseVariable(node);
                                        break;
                                    default:
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                        break;
                                }

                                
                                tok = scanner.LookAhead(TokenType.SEMICOLON);
                                if (tok.Type == TokenType.SEMICOLON)
                                {
                                    tok = scanner.Scan(TokenType.SEMICOLON);
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.SEMICOLON) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                        return;
                                    }
                                }
                                break;
                            case TokenType.K_ENUM:
                                ParseEnum(node);
                                break;
                            case TokenType.K_CLASS:
                                ParseClass(node);
                                break;
                            case TokenType.K_INTERFACE:
                                ParseInterface(node);
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                break;
                        }
                        break;
                    case TokenType.K_IMPORT:
                        ParseImport(node);
                        break;
                    case TokenType.K_EXPORT_EQ:
                        ParseExport(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_FUNCTION, TokenType.K_VAR, TokenType.IDENT, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE, TokenType.K_IMPORT, TokenType.K_EXPORT_EQ);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGeneric(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Generic), "Generic");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.GENERIC);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GENERIC) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GENERIC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseType(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseType(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.SUPERIOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SUPERIOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SUPERIOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFunctionType(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FunctionType), "FunctionType");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SPREADOP, TokenType.IDENT);
            if (tok.Type == TokenType.SPREADOP
                || tok.Type == TokenType.IDENT)
            {
                ParseParamList(node);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.FATARROW);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FATARROW) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FATARROW.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseType(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTypeof(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Typeof), "Typeof");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_TYPEOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_TYPEOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_TYPEOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.DOTIDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOTIDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAnonymousType(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AnonymousType), "AnonymousType");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.K_READONLY, TokenType.FUNCTION, TokenType.IDENT, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM);
            while (tok.Type == TokenType.K_READONLY
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.IDENT
                || tok.Type == TokenType.K_GET
                || tok.Type == TokenType.K_SET
                || tok.Type == TokenType.LBRACKET
                || tok.Type == TokenType.K_ENUM)
            {

                
                tok = scanner.LookAhead(TokenType.K_READONLY);
                if (tok.Type == TokenType.K_READONLY)
                {
                    tok = scanner.Scan(TokenType.K_READONLY);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_READONLY) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_READONLY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                }

                
                tok = scanner.LookAhead(TokenType.FUNCTION, TokenType.IDENT, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM);
                switch (tok.Type)
                {
                    case TokenType.FUNCTION:
                        ParseFunction(node);
                        break;
                    case TokenType.IDENT:
                        ParseVariable(node);
                        break;
                    case TokenType.K_GET:
                        ParseGetter(node);
                        break;
                    case TokenType.K_SET:
                        ParseSetter(node);
                        break;
                    case TokenType.LBRACKET:
                        ParseIndexer(node);
                        break;
                    case TokenType.K_ENUM:
                        ParseEnum(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }

                
                tok = scanner.LookAhead(TokenType.COMMA, TokenType.SEMICOLON);
                if (tok.Type == TokenType.COMMA
                    || tok.Type == TokenType.SEMICOLON)
                {
                    tok = scanner.LookAhead(TokenType.COMMA, TokenType.SEMICOLON);
                    switch (tok.Type)
                    {
                        case TokenType.COMMA:
                            tok = scanner.Scan(TokenType.COMMA);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.COMMA) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.SEMICOLON:
                            tok = scanner.Scan(TokenType.SEMICOLON);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.SEMICOLON) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }
                }
            tok = scanner.LookAhead(TokenType.K_READONLY, TokenType.FUNCTION, TokenType.IDENT, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM);
            }

            
            tok = scanner.Scan(TokenType.RBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseType(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Type), "Type");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.DOTIDENT, TokenType.GENERIC, TokenType.LPAREN, TokenType.K_TYPEOF, TokenType.LBRACE);
            switch (tok.Type)
            {
                case TokenType.DOTIDENT:
                case TokenType.GENERIC:
                case TokenType.LPAREN:
                case TokenType.K_TYPEOF:

                    
                    tok = scanner.LookAhead(TokenType.DOTIDENT, TokenType.GENERIC, TokenType.LPAREN, TokenType.K_TYPEOF);
                    switch (tok.Type)
                    {
                        case TokenType.DOTIDENT:
                            tok = scanner.Scan(TokenType.DOTIDENT);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.DOTIDENT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                            break;
                        case TokenType.GENERIC:
                            ParseGeneric(node);
                            break;
                        case TokenType.LPAREN:
                            ParseFunctionType(node);
                            break;
                        case TokenType.K_TYPEOF:
                            ParseTypeof(node);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                    while (tok.Type == TokenType.ARRAYLEVEL)
                    {
                        tok = scanner.Scan(TokenType.ARRAYLEVEL);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.ARRAYLEVEL) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYLEVEL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                    }

                    
                    tok = scanner.LookAhead(TokenType.VBAR);
                    while (tok.Type == TokenType.VBAR)
                    {

                        
                        tok = scanner.Scan(TokenType.VBAR);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.VBAR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VBAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }

                        
                        tok = scanner.LookAhead(TokenType.DOTIDENT, TokenType.GENERIC, TokenType.LPAREN, TokenType.K_TYPEOF);
                        switch (tok.Type)
                        {
                            case TokenType.DOTIDENT:
                                tok = scanner.Scan(TokenType.DOTIDENT);
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.DOTIDENT) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                    return;
                                }
                                break;
                            case TokenType.GENERIC:
                                ParseGeneric(node);
                                break;
                            case TokenType.LPAREN:
                                ParseFunctionType(node);
                                break;
                            case TokenType.K_TYPEOF:
                                ParseTypeof(node);
                                break;
                            default:
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                                break;
                        }

                        
                        tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                        while (tok.Type == TokenType.ARRAYLEVEL)
                        {
                            tok = scanner.Scan(TokenType.ARRAYLEVEL);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.ARRAYLEVEL) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYLEVEL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                                return;
                            }
                        tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                        }
                    tok = scanner.LookAhead(TokenType.VBAR);
                    }
                    break;
                case TokenType.LBRACE:

                    
                    ParseAnonymousType(node);

                    
                    tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                    while (tok.Type == TokenType.ARRAYLEVEL)
                    {
                        tok = scanner.Scan(TokenType.ARRAYLEVEL);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.ARRAYLEVEL) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYLEVEL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                    tok = scanner.LookAhead(TokenType.ARRAYLEVEL);
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariable(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Variable), "Variable");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.QUESTION);
            if (tok.Type == TokenType.QUESTION)
            {
                tok = scanner.Scan(TokenType.QUESTION);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.QUESTION) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.QUESTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.COLON);
            if (tok.Type == TokenType.COLON)
            {

                
                tok = scanner.Scan(TokenType.COLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.STRING, TokenType.DOTIDENT, TokenType.GENERIC, TokenType.LPAREN, TokenType.K_TYPEOF, TokenType.LBRACE);
                switch (tok.Type)
                {
                    case TokenType.STRING:
                        tok = scanner.Scan(TokenType.STRING);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.STRING) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.DOTIDENT:
                    case TokenType.GENERIC:
                    case TokenType.LPAREN:
                    case TokenType.K_TYPEOF:
                    case TokenType.LBRACE:
                        ParseType(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseIndexer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Indexer), "Indexer");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LBRACKET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACKET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACKET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseVariable(node);

            
            tok = scanner.Scan(TokenType.RBRACKET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACKET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACKET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.COLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseType(node);

            
            tok = scanner.LookAhead(TokenType.SEMICOLON);
            if (tok.Type == TokenType.SEMICOLON)
            {
                tok = scanner.Scan(TokenType.SEMICOLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SEMICOLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParamList(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParamList), "ParamList");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.SPREADOP);
            if (tok.Type == TokenType.SPREADOP)
            {
                tok = scanner.Scan(TokenType.SPREADOP);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SPREADOP) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPREADOP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseVariable(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.SPREADOP);
                if (tok.Type == TokenType.SPREADOP)
                {
                    tok = scanner.Scan(TokenType.SPREADOP);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SPREADOP) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SPREADOP.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                }

                
                ParseVariable(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFunction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Function), "Function");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FUNCTION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SPREADOP, TokenType.IDENT);
            if (tok.Type == TokenType.SPREADOP
                || tok.Type == TokenType.IDENT)
            {
                ParseParamList(node);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COLON);
            if (tok.Type == TokenType.COLON)
            {

                
                tok = scanner.Scan(TokenType.COLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseType(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseBlockElement(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlockElement), "BlockElement");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM);
            switch (tok.Type)
            {
                case TokenType.IDENT:
                case TokenType.FUNCTION:
                case TokenType.K_GET:
                case TokenType.K_SET:

                    
                    tok = scanner.LookAhead(TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET);
                    switch (tok.Type)
                    {
                        case TokenType.IDENT:
                            ParseVariable(node);
                            break;
                        case TokenType.FUNCTION:
                            ParseFunction(node);
                            break;
                        case TokenType.K_GET:
                            ParseGetter(node);
                            break;
                        case TokenType.K_SET:
                            ParseSetter(node);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                            break;
                    }

                    
                    tok = scanner.Scan(TokenType.SEMICOLON);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SEMICOLON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.LBRACKET:
                    ParseIndexer(node);
                    break;
                case TokenType.K_ENUM:
                    ParseEnum(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInterface(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Interface), "Interface");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_INTERFACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_INTERFACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_INTERFACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.GENERIC_ARG);
            if (tok.Type == TokenType.GENERIC_ARG)
            {
                tok = scanner.Scan(TokenType.GENERIC_ARG);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.GENERIC_ARG) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GENERIC_ARG.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.K_EXTENDS, TokenType.K_IMPLEMENTS);
            if (tok.Type == TokenType.K_EXTENDS
                || tok.Type == TokenType.K_IMPLEMENTS)
            {
                ParseExtends(node);
            }

            
            tok = scanner.Scan(TokenType.LBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
            while (tok.Type == TokenType.K_STATIC
                || tok.Type == TokenType.K_EXPORT
                || tok.Type == TokenType.K_READONLY
                || tok.Type == TokenType.K_CONST
                || tok.Type == TokenType.K_LET
                || tok.Type == TokenType.K_PUBLIC
                || tok.Type == TokenType.IDENT
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.K_GET
                || tok.Type == TokenType.K_SET
                || tok.Type == TokenType.LBRACKET
                || tok.Type == TokenType.K_ENUM
                || tok.Type == TokenType.K_CLASS
                || tok.Type == TokenType.K_INTERFACE)
            {

                
                tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                while (tok.Type == TokenType.K_STATIC
                    || tok.Type == TokenType.K_EXPORT
                    || tok.Type == TokenType.K_READONLY
                    || tok.Type == TokenType.K_CONST
                    || tok.Type == TokenType.K_LET
                    || tok.Type == TokenType.K_PUBLIC)
                {
                    ParseAccessTag(node);
                tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                }

                
                tok = scanner.LookAhead(TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
                switch (tok.Type)
                {
                    case TokenType.IDENT:
                    case TokenType.FUNCTION:
                    case TokenType.K_GET:
                    case TokenType.K_SET:
                    case TokenType.LBRACKET:
                    case TokenType.K_ENUM:
                        ParseBlockElement(node);
                        break;
                    case TokenType.K_CLASS:
                        ParseClass(node);
                        break;
                    case TokenType.K_INTERFACE:
                        ParseInterface(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
            }

            
            tok = scanner.Scan(TokenType.RBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SEMICOLON);
            if (tok.Type == TokenType.SEMICOLON)
            {
                tok = scanner.Scan(TokenType.SEMICOLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SEMICOLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseClass(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Class), "Class");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_CLASS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_CLASS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_CLASS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.GENERIC_ARG);
            if (tok.Type == TokenType.GENERIC_ARG)
            {
                tok = scanner.Scan(TokenType.GENERIC_ARG);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.GENERIC_ARG) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GENERIC_ARG.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.K_EXTENDS, TokenType.K_IMPLEMENTS);
            if (tok.Type == TokenType.K_EXTENDS
                || tok.Type == TokenType.K_IMPLEMENTS)
            {
                ParseExtends(node);
            }

            
            tok = scanner.Scan(TokenType.LBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
            while (tok.Type == TokenType.K_STATIC
                || tok.Type == TokenType.K_EXPORT
                || tok.Type == TokenType.K_READONLY
                || tok.Type == TokenType.K_CONST
                || tok.Type == TokenType.K_LET
                || tok.Type == TokenType.K_PUBLIC
                || tok.Type == TokenType.IDENT
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.K_GET
                || tok.Type == TokenType.K_SET
                || tok.Type == TokenType.LBRACKET
                || tok.Type == TokenType.K_ENUM
                || tok.Type == TokenType.K_CLASS
                || tok.Type == TokenType.K_INTERFACE)
            {

                
                tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                while (tok.Type == TokenType.K_STATIC
                    || tok.Type == TokenType.K_EXPORT
                    || tok.Type == TokenType.K_READONLY
                    || tok.Type == TokenType.K_CONST
                    || tok.Type == TokenType.K_LET
                    || tok.Type == TokenType.K_PUBLIC)
                {
                    ParseAccessTag(node);
                tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
                }

                
                tok = scanner.LookAhead(TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
                switch (tok.Type)
                {
                    case TokenType.IDENT:
                    case TokenType.FUNCTION:
                    case TokenType.K_GET:
                    case TokenType.K_SET:
                    case TokenType.LBRACKET:
                    case TokenType.K_ENUM:
                        ParseBlockElement(node);
                        break;
                    case TokenType.K_CLASS:
                        ParseClass(node);
                        break;
                    case TokenType.K_INTERFACE:
                        ParseInterface(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC, TokenType.IDENT, TokenType.FUNCTION, TokenType.K_GET, TokenType.K_SET, TokenType.LBRACKET, TokenType.K_ENUM, TokenType.K_CLASS, TokenType.K_INTERFACE);
            }

            
            tok = scanner.Scan(TokenType.RBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SEMICOLON);
            if (tok.Type == TokenType.SEMICOLON)
            {
                tok = scanner.Scan(TokenType.SEMICOLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SEMICOLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAccessTag(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AccessTag), "AccessTag");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.K_STATIC, TokenType.K_EXPORT, TokenType.K_READONLY, TokenType.K_CONST, TokenType.K_LET, TokenType.K_PUBLIC);
            switch (tok.Type)
            {
                case TokenType.K_STATIC:
                    tok = scanner.Scan(TokenType.K_STATIC);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_STATIC) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_STATIC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_EXPORT:
                    tok = scanner.Scan(TokenType.K_EXPORT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_EXPORT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_EXPORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_READONLY:
                    tok = scanner.Scan(TokenType.K_READONLY);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_READONLY) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_READONLY.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_CONST:
                    tok = scanner.Scan(TokenType.K_CONST);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_CONST) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_CONST.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_LET:
                    tok = scanner.Scan(TokenType.K_LET);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_LET) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_LET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_PUBLIC:
                    tok = scanner.Scan(TokenType.K_PUBLIC);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_PUBLIC) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_PUBLIC.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseGetter(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Getter), "Getter");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_GET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_GET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_GET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SPREADOP, TokenType.IDENT);
            if (tok.Type == TokenType.SPREADOP
                || tok.Type == TokenType.IDENT)
            {
                ParseParamList(node);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.COLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseType(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetter(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Setter), "Setter");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_SET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_SET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_SET.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SPREADOP, TokenType.IDENT);
            if (tok.Type == TokenType.SPREADOP
                || tok.Type == TokenType.IDENT)
            {
                ParseParamList(node);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.COLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseType(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExtends(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Extends), "Extends");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.K_EXTENDS, TokenType.K_IMPLEMENTS);
            switch (tok.Type)
            {
                case TokenType.K_EXTENDS:
                    tok = scanner.Scan(TokenType.K_EXTENDS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_EXTENDS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_EXTENDS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_IMPLEMENTS:
                    tok = scanner.Scan(TokenType.K_IMPLEMENTS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_IMPLEMENTS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_IMPLEMENTS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOTIDENT, TokenType.GENERIC);
            switch (tok.Type)
            {
                case TokenType.DOTIDENT:
                    tok = scanner.Scan(TokenType.DOTIDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOTIDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.GENERIC:
                    ParseGeneric(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.DOTIDENT, TokenType.GENERIC);
                switch (tok.Type)
                {
                    case TokenType.DOTIDENT:
                        tok = scanner.Scan(TokenType.DOTIDENT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DOTIDENT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.GENERIC:
                        ParseGeneric(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExport(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Export), "Export");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_EXPORT_EQ);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_EXPORT_EQ) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_EXPORT_EQ.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            

            
            tok = scanner.LookAhead(TokenType.DOLLAR, TokenType.IDENT);
            switch (tok.Type)
            {
                case TokenType.DOLLAR:
                    tok = scanner.Scan(TokenType.DOLLAR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOLLAR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOLLAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT:
                    tok = scanner.Scan(TokenType.IDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOT);
            while (tok.Type == TokenType.DOT)
            {

                
                tok = scanner.Scan(TokenType.DOT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DOT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.Scan(TokenType.IDENT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.DOT);
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SEMICOLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseImport(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Import), "Import");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_IMPORT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_IMPORT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_IMPORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.DOTIDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOTIDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.EQUALS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EQUALS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EQUALS.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.K_NAMESPACE, TokenType.K_MODULE, TokenType.K_REQUIRE);
            switch (tok.Type)
            {
                case TokenType.K_NAMESPACE:
                    tok = scanner.Scan(TokenType.K_NAMESPACE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_NAMESPACE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_NAMESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_MODULE:
                    tok = scanner.Scan(TokenType.K_MODULE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_MODULE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_MODULE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.K_REQUIRE:
                    tok = scanner.Scan(TokenType.K_REQUIRE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.K_REQUIRE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_REQUIRE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
            switch (tok.Type)
            {
                case TokenType.DOUBLEQUOTE:
                    tok = scanner.Scan(TokenType.DOUBLEQUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLEQUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SIMPLEQUOTE:
                    tok = scanner.Scan(TokenType.SIMPLEQUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SIMPLEQUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIMPLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED, TokenType.DOTIDENT);
            switch (tok.Type)
            {
                case TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED:
                    tok = scanner.Scan(TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT_WITH_ADDITIONAL_CHARS_ALLOWED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DOTIDENT:
                    tok = scanner.Scan(TokenType.DOTIDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOTIDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOTIDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DOUBLEQUOTE, TokenType.SIMPLEQUOTE);
            switch (tok.Type)
            {
                case TokenType.DOUBLEQUOTE:
                    tok = scanner.Scan(TokenType.DOUBLEQUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLEQUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SIMPLEQUOTE:
                    tok = scanner.Scan(TokenType.SIMPLEQUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SIMPLEQUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIMPLEQUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SEMICOLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseEnum(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Enum), "Enum");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.K_ENUM);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.K_ENUM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.K_ENUM.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.LBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENT);
            while (tok.Type == TokenType.IDENT)
            {

                
                tok = scanner.Scan(TokenType.IDENT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.COMMA);
                if (tok.Type == TokenType.COMMA)
                {
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                }
            tok = scanner.LookAhead(TokenType.IDENT);
            }

            
            tok = scanner.Scan(TokenType.RBRACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RBRACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RBRACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
